{
  "name": "Facebook",
  "tagline": "A Facebook Graph API SDK Library For Golang",
  "body": "# A Facebook Graph API SDK In Golang #\r\n\r\n[![Build Status](https://travis-ci.org/huandu/facebook.png?branch=master)](https://travis-ci.org/huandu/facebook)\r\n\r\nThis is a Go package fully supports Facebook Graph API with file upload, batch request, FQL and multi-FQL. It can be used in Google App Engine.\r\n\r\nAPI documents can be found on [godoc](http://godoc.org/github.com/huandu/facebook).\r\n\r\nFeel free to create an issue or send me a pull request if you have any \"how-to\" question or bug or suggestion when using this package. I'll try my best to reply it.\r\n\r\n## Get It ##\r\n\r\nUse `go get -u github.com/huandu/facebook` to get or update it.\r\n\r\n## Usage ##\r\n\r\n### Quick start ###\r\n\r\nHere is a sample to read my Facebook first name by uid.\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    fb \"github.com/huandu/facebook\"\r\n)\r\n\r\nfunc main() {\r\n    res, _ := fb.Get(\"/538744468\", fb.Params{\r\n        \"fields\": \"first_name\",\r\n        \"access_token\": \"a-valid-access-token\",\r\n    })\r\n    fmt.Println(\"here is my facebook first name:\", res[\"first_name\"])\r\n}\r\n```\r\n\r\nType of `res` is `fb.Result` (a.k.a. `map[string]interface{}`).\r\nThis type has several useful methods to decode `res` to any Go type safely.\r\n\r\n```go\r\n// Decode \"first_name\" to a Go string.\r\nvar first_name string\r\nres.DecodeField(\"first_name\", &first_name)\r\nfmt.Println(\"alternative way to get first_name:\", first_name)\r\n\r\n// It's also possible to decode the whole result into a predefined struct.\r\ntype User struct {\r\n    FirstName string\r\n}\r\n\r\nvar user User\r\nres.Decode(&user)\r\nfmt.Println(\"print first_name in struct:\", user.FirstName)\r\n```\r\n\r\nIf a type implements `json.Unmarshaler` interface, `Decode` or `DecodeField` will use it to unmarshal JSON.\r\n\r\n```go\r\nres := Result{\r\n    \"create_time\": \"2006-01-02 15:16:17Z\",\r\n}\r\n\r\n// Type `*time.Time` implements `json.Unmarshaler`.\r\n// res.DecodeField will use the interface to unmarshal data.\r\nvar tm time.Time\r\nres.DecodeField(\"create_time\", &tm)\r\n```\r\n\r\n### Read a graph `user` object with a valid access token ###\r\n\r\n```go\r\nres, err := fb.Get(\"/me/feed\", fb.Params{\r\n     \"access_token\": \"a-valid-access-token\",\r\n})\r\n\r\nif err != nil {\r\n    // err can be an facebook API error.\r\n    // if so, the Error struct contains error details.\r\n    if e, ok := err.(*Error); ok {\r\n        fmt.Logf(\"facebook error. [message:%v] [type:%v] [code:%v] [subcode:%v]\",\r\n            e.Message, e.Type, e.Code, e.ErrorSubcode)\r\n        return\r\n    }\r\n\r\n    return\r\n}\r\n\r\n// read my last feed.\r\nfmt.Println(\"my latest feed story is:\", res.Get(\"data.0.story\"))\r\n```\r\n\r\n### Read a graph `search` for page and decode slice of maps\r\n\r\n```go\r\nres, _ := fb.Get(\"/search\", fb.Params{\r\n        \"access_token\": \"a-valid-access-token\",\r\n        \"type\":         \"page\",\r\n        \"q\":            \"nightlife,singapore\",\r\n    })\r\n\r\nvar items []fb.Result\r\n\r\nerr := res.DecodeField(\"data\", &items)\r\n\r\nif err != nil {\r\n    fmt.Logf(\"An error has happened %v\", err)\r\n    return\r\n}\r\n\r\nfor _, item := range items {\r\n    fmt.Println(item[\"id\"])\r\n}\r\n```\r\n\r\n### Use `App` and `Session` ###\r\n\r\nIt's recommended to use `App` and `Session` in a production app. They provide more controls over all API calls. They can also make code clear and concise.\r\n\r\n```go\r\n// create a global App var to hold app id and secret.\r\nvar globalApp = fb.New(\"your-app-id\", \"your-app-secret\")\r\n\r\n// facebook asks for a valid redirect uri when parsing signed request.\r\n// it's a new enforced policy starting in late 2013.\r\nglobalApp.RedirectUri = \"http://your.site/canvas/url/\"\r\n\r\n// here comes a client with a facebook signed request string in query string.\r\n// creates a new session with signed request.\r\nsession, _ := globalApp.SessionFromSignedRequest(signedRequest)\r\n\r\n// if there is another way to get decoded access token,\r\n// creates a session directly with the token.\r\nsession := globalApp.Session(token)\r\n\r\n// validate access token. err is nil if token is valid.\r\nerr := session.Validate()\r\n\r\n// use session to send api request with access token.\r\nres, _ := session.Get(\"/me/feed\", nil)\r\n```\r\n\r\n### Use `paging` field in response. ###\r\n\r\nSome Graph API responses use a special JSON structure to provide paging information. Use `Result.Paging()` to walk through all data in such results.\r\n\r\n```go\r\nres, _ := session.Get(\"/me/home\", nil)\r\n\r\n// create a paging structure.\r\npaging, _ := res.Paging(session)\r\n\r\n// get current results.\r\nresults := paging.Data()\r\n\r\n// get next page.\r\nnoMore, err := paging.Next()\r\nresults = paging.Data()\r\n```\r\n\r\n### Read graph api response and decode result into a struct ###\r\n\r\nAs facebook Graph API always uses lower case words as keys in API response.\r\nThis package can convert go's camel-case-style struct field name to facebook's underscore-style API key name.\r\n\r\nFor instance, to decode following JSON response...\r\n\r\n```json\r\n{\r\n    \"foo_bar\": \"player\"\r\n}\r\n```\r\n\r\nOne can use following struct.\r\n\r\n```go\r\ntype Data struct {\r\n    FooBar string  // \"FooBar\" maps to \"foo_bar\" in JSON automatically in this case.\r\n}\r\n```\r\n\r\nDecoding behavior can be changed per field through field tag -- just like what `encoding/json` does.\r\n\r\nFollowing is a sample shows all possible field tags.\r\n\r\n```go\r\n// define a facebook feed object.\r\ntype FacebookFeed struct {\r\n    Id          string `facebook:\",required\"`             // this field must exist in response.\r\n                                                          // mind the \",\" before \"required\".\r\n    Story       string\r\n    FeedFrom    *FacebookFeedFrom `facebook:\"from\"`       // use customized field name \"from\".\r\n    CreatedTime string `facebook:\"created_time,required\"` // both customized field name and \"required\" flag.\r\n    Omitted     string `facebook:\"-\"`                     // this field is omitted when decoding.\r\n}\r\n\r\ntype FacebookFeedFrom struct {\r\n    Name, Id string\r\n}\r\n\r\n// create a feed object direct from graph api result.\r\nvar feed FacebookFeed\r\nres, _ := session.Get(\"/me/feed\", nil)\r\nres.DecodeField(\"data.0\", &feed) // read latest feed\r\n```\r\n\r\n### Send a batch request ###\r\n\r\n```go\r\nparams1 := Params{\r\n    \"method\": fb.GET,\r\n    \"relative_url\": \"me\",\r\n}\r\nparams2 := Params{\r\n    \"method\": fb.GET,\r\n    \"relative_url\": uint64(100002828925788),\r\n}\r\nresults, err := fb.BatchApi(your_access_token, params1, params2)\r\n\r\nif err != nil {\r\n    // check error...\r\n    return\r\n}\r\n\r\n// batchResult1 and batchResult2 are response for params1 and params2.\r\nbatchResult1, _ := results[0].Batch()\r\nbatchResult2, _ := results[1].Batch()\r\n\r\n// Use parsed result.\r\nvar id string\r\nres := batchResult1.Result\r\nres.DecodeField(\"id\", &id)\r\n\r\n// Use response header.\r\ncontentType := batchResult1.Header.Get(\"Content-Type\")\r\n```\r\n\r\n### Send FQL query ###\r\n\r\n```go\r\nresults, _ := fb.FQL(\"SELECT username FROM page WHERE page_id = 20531316728\")\r\nfmt.Println(results[0][\"username\"]) // print \"facebook\"\r\n\r\n// most FQL query requires access token. create session to hold access token.\r\nsession := &fb.Session{}\r\nsession.SetAccessToken(\"A-VALID-ACCESS-TOKEN\")\r\nresults, _ := session.FQL(\"SELECT username FROM page WHERE page_id = 20531316728\")\r\nfmt.Println(results[0][\"username\"]) // print \"facebook\"\r\n```\r\n\r\n### Make multi-FQL ###\r\n\r\n```go\r\nres, _ := fb.MultiFQL(Params{\r\n    \"query1\": \"SELECT username FROM page WHERE page_id = 20531316728\",\r\n    \"query2\": \"SELECT uid FROM user WHERE uid = 538744468\",\r\n})\r\nvar query1, query2 []Result\r\n\r\n// get response for query1 and query2.\r\nres.DecodeField(\"query1\", &query1)\r\nres.DecodeField(\"query2\", &query2)\r\n\r\n// most FQL query requires access token. create session to hold access token.\r\nsession := &fb.Session{}\r\nsession.SetAccessToken(\"A-VALID-ACCESS-TOKEN\")\r\nres, _ := session.MultiFQL(Params{\r\n    \"query1\": \"...\",\r\n    \"query2\": \"...\",\r\n})\r\n\r\n// same as the sample without access token...\r\n```\r\n\r\n### Use it in Google App Engine ###\r\n\r\nGoogle App Engine provide `appengine/urlfetch` package as standard http client package. Default client in `net/http` doesn't work. One must explicitly set http client in `Session` to make it work.\r\n\r\n```go\r\nimport (\r\n    \"appengine\"\r\n    \"appengine/urlfetch\"\r\n)\r\n\r\n// suppose it's the appengine context initialized somewhere.\r\nvar context appengine.Context\r\n\r\n// default Session object uses http.DefaultClient which is not allowed to use\r\n// in appengine. one has to create a Session and assign it a special client.\r\nseesion := globalApp.Session(\"a-access-token\")\r\nsession.HttpClient = urlfetch.Client(context)\r\n\r\n// now, session uses appengine http client now.\r\nres, err := session.Get(\"/me\", nil)\r\n```\r\n\r\n### Select Graph API version ###\r\n\r\nSee [Platform Versioning](https://developers.facebook.com/docs/apps/versions) to understand facebook versioning strategy.\r\n\r\n```go\r\n// this package uses default version which is controlled by facebook app setting.\r\n// change following global variable to specific a global default version.\r\nfb.Version = \"v2.0\"\r\n\r\n// starting with graph api v2.0, it's not allowed to get user information without access token.\r\nfb.Api(\"huan.du\", GET, nil)\r\n\r\n// it's possible to specify version per session.\r\nsession := &fb.Session{}\r\nsession.Version = \"v2.0\" // overwrite global default.\r\n```\r\n\r\n### Enable `appsecret_proof` ###\r\n\r\nFacebook can verify Graph API Calls with `appsecret_proof`. It's a feature to make Graph API call more secure. See [Securing Graph API Requests](https://developers.facebook.com/docs/graph-api/securing-requests) to know more about it.\r\n\r\n```go\r\nglobalApp := fb.New(\"your-app-id\", \"your-app-secret\")\r\n\r\n// enable \"appsecret_proof\" for all sessions created by this app.\r\nglobalApp.EnableAppsecretProof = true\r\n\r\n// all calls in this session are secured.\r\nsession := globalApp.Session(\"a-valid-access-token\")\r\nsession.Get(\"/me\", nil)\r\n\r\n// it's also possible to enable/disable this feature per session.\r\nsession.EnableAppsecretProof(false)\r\n```\r\n\r\n### Debugging API Requests ###\r\n\r\nFacebook introduces a way to debug graph API calls. See [Debugging API Requests](https://developers.facebook.com/docs/graph-api/using-graph-api/v2.3#debugging) for details.\r\n\r\nThis package provides both package level and per session debug flag. Set `Debug` to a `DEBUG_*` constant to change debug mode globally; or use `Session#SetDebug` to change debug mode for one session.\r\n\r\nWhen debug mode is turned on, use `Result#DebugInfo` to get `DebugInfo` struct from result.\r\n\r\n```go\r\nfb.Debug = fb.DEBUG_ALL\r\n\r\nres, _ := fb.Get(\"/me\", fb.Params{\"access_token\": \"xxx\"})\r\ndebugInfo := res.DebugInfo()\r\n\r\nfmt.Println(\"http headers:\", debugInfo.Header)\r\nfmt.Println(\"facebook api version:\", debugInfo.FacebookApiVersion)\r\n```\r\n\r\n### Work with package `golang.org/x/oauth2` ##\r\n\r\nPackage `golang.org/x/oauth2` can handle facebook OAuth2 authentication process and access token very well. This package can work with it by setting `Session#HttpClient` to OAuth2's client.\r\n\r\n```go\r\nimport (\r\n    \"golang.org/x/oauth2\"\r\n    oauth2fb \"golang.org/x/oauth2/facebook\"\r\n    fb \"github.com/huandu/facebook\"\r\n)\r\n\r\n// Get facebook access token.\r\nconf := &oauth2.Config{\r\n    ClientID:     \"AppId\",\r\n    ClientSecret: \"AppSecret\",\r\n    RedirectURL:  \"CallbackURL\",\r\n    Scopes:       []string{\"email\"},\r\n    Endpoint:     oauth2fb.Endpoint,\r\n}\r\ntoken, err := conf.Exchange(oauth2.NoContext, \"code\")\r\n\r\n// Create a client to manage access token life cycle.\r\nclient := conf.Client(oauth2.NoContext, token)\r\n\r\n// Use OAuth2 client with session.\r\nsession := &fb.Session{\r\n    Version:    \"v2.4\",\r\n    HttpClient: client,\r\n}\r\n\r\n// Use session.\r\nres, _ := session.Get(\"/me\", nil)\r\n```\r\n\r\n## Change Log ##\r\n\r\nSee [CHANGELOG.md](CHANGELOG.md).\r\n\r\n## Out of Scope ##\r\n\r\n1. No OAuth integration. This package only provides APIs to parse/verify access token and code generated in OAuth 2.0 authentication process.\r\n2. No old RESTful API support. Such APIs are deprecated for years. Forget about them.\r\n\r\n## License ##\r\n\r\nThis package is licensed under MIT license. See LICENSE for details.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}